<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Neon Serpent ‚Äî Remodeled</title>
  <meta name="description" content="Neon Serpent remodelado: interfaz y animaciones profesionales, audio sintetizado, controles t√°ctiles y pulido visual." />
  <style>
    /* --------------------
       Reset + base
       -------------------- */
    :root{
      --bg:#04040a;
      --panel: rgba(12,10,20,0.55);
      --glass: rgba(255,255,255,0.04);
      --accent1:#00dbde;
      --accent2:#fc00ff;
      --muted:#9aa0ff;
      --glass-border: rgba(120,100,255,0.12);
      --radius:14px;
      --ui-gap:12px;
      --safe-width:480px;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body,#root{height:100%}
    body{
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      background: radial-gradient(1200px 600px at 10% 10%, rgba(0,219,222,0.06), transparent),
                  radial-gradient(900px 500px at 90% 90%, rgba(252,0,255,0.05), transparent),
                  var(--bg);
      color:#eaf0ff;
      display:flex;align-items:center;justify-content:center;padding:28px;overflow:hidden;
    }

    /* ---------- App shell ---------- */
    .app{
      width:100%;max-width:930px;display:grid;gap:18px;grid-template-columns:1fr 380px;align-items:start;
      align-content:center;
    }

    /* Left: canvas area */
    .stage{
      background: linear-gradient(180deg, rgba(10,8,20,0.6), rgba(5,3,12,0.6));
      border-radius:18px;padding:20px;position:relative;overflow:hidden;box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Neon glow rim */
    .stage:before{
      content:"";position:absolute;inset:-2px;border-radius:20px;pointer-events:none;
      background:linear-gradient(90deg,var(--accent1),var(--accent2));opacity:0.06;mix-blend-mode:screen;
      filter: blur(18px);
    }

    canvas{display:block;width:100%;height:calc(100% - 64px);max-height:640px;border-radius:12px;background:linear-gradient(180deg, rgba(5,3,15,0.75), rgba(2,2,8,0.85));box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);}

    /* HUD on canvas */
    .hud{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:8px 4px;color:var(--muted)}
    .score{font-weight:700;font-size:1.05rem;letter-spacing:0.6px}
    .small{font-size:0.86rem;color:#b7bdff}

    /* Right column: controls & info */
    .panel{
      background: linear-gradient(180deg, rgba(15,12,40,0.6), rgba(8,6,22,0.55));
      border-radius: var(--radius);padding:18px;width:100%;min-width:260px;border:1px solid var(--glass-border);
      backdrop-filter: blur(8px);box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }

    .brand{font-weight:800;font-size:1.6rem;background:linear-gradient(90deg,var(--accent1),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent}
    .sub{color:var(--muted);font-size:0.9rem;margin-top:6px}

    .row{display:flex;gap:10px;align-items:center;margin-top:14px;flex-wrap:wrap}
    .label{font-size:0.78rem;color:var(--muted);font-weight:600}

    .options{display:flex;gap:10px;flex-wrap:wrap}
    .swatch{width:40px;height:40px;border-radius:10px;border:2px solid transparent;cursor:pointer;display:flex;align-items:center;justify-content:center}
    .swatch.active{transform:scale(1.08);box-shadow:0 8px 30px rgba(0,0,0,0.6),0 0 18px rgba(0,219,222,0.12);border-color:rgba(255,255,255,0.07)}

    .btn{appearance:none;border:none;padding:10px 16px;border-radius:999px;font-weight:700;cursor:pointer;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#061223;box-shadow:0 6px 18px rgba(252,0,255,0.16);}
    .ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}

    .controls{display:flex;gap:8px;align-items:center}

    /* Start / overlay screens */
    .overlay{position:absolute;inset:0;background:linear-gradient(180deg, rgba(6,5,10,0.6), rgba(2,2,6,0.7));display:flex;flex-direction:column;align-items:center;justify-content:center;padding:30px;backdrop-filter: blur(4px);transition:opacity .34s cubic-bezier(.2,.9,.2,1), transform .34s cubic-bezier(.2,.9,.2,1)}
    .overlay.hidden{opacity:0;pointer-events:none;transform:translateY(6px) scale(.995)}
    .overlay .title{font-size:2.2rem;font-weight:900;letter-spacing:1px;margin-bottom:8px;background:linear-gradient(90deg,var(--accent1),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent}
    .overlay .desc{color:var(--muted);text-align:center;max-width:420px;margin-bottom:18px}
    .overlay .cta{display:flex;gap:10px}

    /* particles + small helpers */
    .meta{font-size:0.82rem;color:var(--muted);margin-top:12px}

    /* responsive */
    @media (max-width:880px){.app{grid-template-columns:1fr}.panel{order:2;margin-top:12px}.stage{order:1}}
    @media (max-width:520px){body{padding:14px}.panel{padding:12px}.brand{font-size:1.25rem}}
  </style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <div class="hud">
        <div>
          <div class="score">Puntuaci√≥n: <span id="score">0</span></div>
          <div class="small">Mejor: <span id="best">0</span></div>
        </div>
        <div class="small">FPS: <span id="fps">0</span></div>
      </div>

      <canvas id="canvas"></canvas>

      <!-- Overlay de inicio / pausa / game over -->
      <div id="overlay" class="overlay">
        <div class="title">NEON SERPENT</div>
        <div class="desc">Snake moderno con est√©tica ne√≥n. Toca o presiona para empezar. Usa WASD/‚óÑ‚ñ≤‚ñ∫‚ñº o desliza en m√≥vil.</div>
        <div class="cta">
          <button id="startBtn" class="btn">JUGAR</button>
          <button id="howBtn" class="ghost btn">C√ìMO JUGAR</button>
        </div>
        <div class="meta">Puedes cambiar color, alimento y velocidad en la derecha.</div>
      </div>

      <div id="overlayGameOver" class="overlay hidden" style="pointer-events:none;">
        <div class="title">¬°JUEGO TERMINADO!</div>
        <div class="desc">Puntuaci√≥n final: <strong id="finalScore">0</strong></div>
        <div class="cta">
          <button id="restartBtn" class="btn">JUGAR DE NUEVO</button>
          <button id="shareBtn" class="ghost btn">COMPARTIR</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="brand">NEON SERPENT</div>
      <div class="sub">Remodelado: animaciones, audio sintetizado y controles t√°ctiles mejorados.</div>

      <div class="row">
        <div class="label">Color</div>
        <div class="options" id="colorOptions"></div>
      </div>

      <div class="row">
        <div class="label">Alimento</div>
        <div class="options" id="foodOptions"></div>
      </div>

      <div class="row">
        <div class="label">Velocidad</div>
        <div class="options" id="speedOptions"></div>
      </div>

      <div class="row controls" style="margin-top:16px;">
        <button id="soundToggle" class="ghost btn">SOUND: ON</button>
        <button id="vibeToggle" class="ghost btn">VIB: ON</button>
        <div style="flex:1"></div>
        <button id="previewBtn" class="btn">VISTA PREVIA</button>
      </div>

      <div class="meta">Consejo: en m√≥vil, desactiva el bloqueo de rotaci√≥n para mejor experiencia.</div>
    </div>
  </div>

  <script>
  // =========================
  // Neon Serpent ‚Äî Remodelado
  // - Procedural audio (WebAudio)
  // - Polished UI transitions
  // - Particle pops
  // - DPR safe canvas
  // - Fixed timestep game loop
  // =========================
  (function(){
    'use strict';

    // Configuration
    const COLOR_PRESETS = [ '#00dbde','#fc00ff','#a4ff00','#00bfff','#8a2be2','#ff6b35' ];
    const FOOD_PRESETS = [ {emoji:'üçé', color:'#ff2a6d'}, {emoji:'üçí', color:'#e53935'}, {emoji:'üçá', color:'#7e57c2'}, {emoji:'üçã', color:'#ffd600'}, {emoji:'ü•ù', color:'#8bc34a'}, {emoji:'üçë', color:'#ff9e80'} ];
    const SPEED_LEVELS = [ {name:'Suave',ms:220},{name:'Normal',ms:140},{name:'R√°pido',ms:95},{name:'Demencial',ms:50} ];
    const GRID_SIZE = 20; // px per cell

    // State
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let overlay = document.getElementById('overlay');
    let overlayGameOver = document.getElementById('overlayGameOver');
    let scoreEl = document.getElementById('score');
    let bestEl = document.getElementById('best');
    let finalScoreEl = document.getElementById('finalScore');
    let fpsEl = document.getElementById('fps');

    let widthPx = 480, heightPx = 480; // logical canvas display size (CSS pixels)
    let dpr = Math.max(1, window.devicePixelRatio || 1);

    let gridW, gridH;
    let snake = [];
    let food = {x:0,y:0,type:FOOD_PRESETS[0]};
    let dir = {x:1,y:0};
    let nextDir = {x:1,y:0};
    let score = 0;
    let best = parseInt(localStorage.getItem('neonSerpentBest')||'0',10)||0;
    let running=false, started=false;
    let selectedColor = COLOR_PRESETS[0];
    let selectedFood = FOOD_PRESETS[0];
    let selectedSpeed = SPEED_LEVELS[1].ms;
    let soundOn = true; let vibOn = true;

    bestEl.textContent = best;

    // Particles
    const particles = [];
    function spawnParticles(x,y,color){
      for(let i=0;i<12;i++){
        particles.push({x,y,vx:(Math.random()-0.5)*2.6,vy:(Math.random()-0.8)*2.6,life:Math.random()*600+300,age:0, color});
      }
    }

    // Audio - simple procedural effects via WebAudio
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audio = AudioCtx ? new AudioCtx() : null;
    function beep(freq, type='sine', time=0.08, gain=0.12){
      if(!audio||!soundOn) return;
      const now = audio.currentTime;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audio.destination);
      o.start(now); g.gain.exponentialRampToValueAtTime(0.001, now+time);
      o.stop(now+time+0.02);
    }
    function popSound(){ beep(880,'sawtooth',0.10,0.12); }
    function turnSound(){ beep(440,'sine',0.06,0.06); }
    function dieSound(){ if(!audio||!soundOn) return; const now=audio.currentTime; const o=audio.createOscillator(); const g=audio.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(240, now); o.frequency.exponentialRampToValueAtTime(60, now+0.6); g.gain.value=0.2; o.connect(g); g.connect(audio.destination); o.start(now); g.gain.exponentialRampToValueAtTime(0.001, now+0.6); o.stop(now+0.7); }

    // Helpers
    function setCanvasSize(){
      const rect = canvas.getBoundingClientRect();
      widthPx = Math.max(200, Math.min(rect.width, 900));
      heightPx = rect.height || widthPx; // square-ish
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(widthPx * dpr);
      canvas.height = Math.floor(heightPx * dpr);
      canvas.style.width = widthPx + 'px';
      canvas.style.height = heightPx + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      gridW = Math.floor(widthPx / GRID_SIZE);
      gridH = Math.floor(heightPx / GRID_SIZE);
    }

    function newGame(){
      snake = [];
      const cx = Math.floor(gridW/2), cy = Math.floor(gridH/2);
      snake.push({x:cx,y:cy});
      snake.push({x:cx-1,y:cy});
      snake.push({x:cx-2,y:cy});
      dir={x:1,y:0}; nextDir={x:1,y:0};
      score=0; scoreEl.textContent = score;
      placeFood();
      running=true; started=true; overlay.classList.add('hidden'); overlay.style.pointerEvents='none'; overlayGameOver.classList.add('hidden');
    }

    function placeFood(){
      let fx,fy,ok;
      do{
        fx = Math.floor(Math.random()*gridW);
        fy = Math.floor(Math.random()*gridH);
        ok = !snake.some(s=>s.x===fx && s.y===fy);
      }while(!ok);
      food = {x:fx,y:fy,type:selectedFood};
    }

    // Controls
    const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints>0;
    let touchStartX=0,touchStartY=0;
    canvas.addEventListener('touchstart', e=>{ if(e.touches && e.touches[0]){ touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY;} }, {passive:true});
    canvas.addEventListener('touchend', e=>{
      if(!running) return;
      const t = e.changedTouches[0]; const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY; const absx=Math.abs(dx), absy=Math.abs(dy);
      const thresh = 20; if(Math.max(absx,absy) < thresh) return; let nd;
      if(absx>absy) nd = dx>0?{x:1,y:0}:{x:-1,y:0}; else nd = dy>0?{x:0,y:1}:{x:0,y:-1};
      setNextDir(nd);
    }, {passive:true});

    window.addEventListener('keydown', e=>{
      if(!running && !started && (e.key===' '|| e.key==='Enter')){ newGame(); return; }
      if(!running) return;
      const map = {ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0}, w:{x:0,y:-1}, a:{x:-1,y:0}, s:{x:0,y:1}, d:{x:1,y:0}};
      const k = e.key.length===1? e.key.toLowerCase() : e.key;
      if(map[k]) setNextDir(map[k]);
    });

    function setNextDir(nd){
      // prevent 180
      if(nd.x === -dir.x && nd.y === -dir.y) return;
      nextDir = nd; if(soundOn) turnSound();
    }

    // UI wiring for options
    const colorOptions = document.getElementById('colorOptions');
    const foodOptions = document.getElementById('foodOptions');
    const speedOptions = document.getElementById('speedOptions');

    function buildOptions(){
      COLOR_PRESETS.forEach((c,i)=>{
        const el = document.createElement('div'); el.className='swatch'; el.style.background=c; el.title=c; if(i===0) el.classList.add('active');
        el.addEventListener('click', ()=>{ selectedColor=c; document.querySelectorAll('#colorOptions .swatch').forEach(x=>x.classList.remove('active')); el.classList.add('active'); }); colorOptions.appendChild(el);
      });
      FOOD_PRESETS.forEach((f,i)=>{
        const el = document.createElement('div'); el.className='swatch'; el.textContent=f.emoji; el.title=f.emoji; if(i===0) el.classList.add('active');
        el.addEventListener('click', ()=>{ selectedFood=f; document.querySelectorAll('#foodOptions .swatch').forEach(x=>x.classList.remove('active')); el.classList.add('active'); placeFood(); if(!running) renderPreview(); }); foodOptions.appendChild(el);
      });
      SPEED_LEVELS.forEach((s,i)=>{
        const el = document.createElement('button'); el.className='swatch'; el.style.display='inline-flex'; el.style.alignItems='center'; el.style.justifyContent='center'; el.textContent=s.name; if(i===1) el.classList.add('active');
        el.addEventListener('click', ()=>{ selectedSpeed=s.ms; document.querySelectorAll('#speedOptions .swatch').forEach(x=>x.classList.remove('active')); el.classList.add('active'); localStorage.setItem('neonSpeed',s.ms); }); speedOptions.appendChild(el);
      });
    }

    // initialize options
    buildOptions();
    const savedSpeed = parseInt(localStorage.getItem('neonSpeed')||'0',10);
    if(savedSpeed) selectedSpeed = savedSpeed;

    // overlay buttons
    document.getElementById('startBtn').addEventListener('click', ()=>{ if(audio && audio.state==='suspended') audio.resume(); newGame(); });
    document.getElementById('restartBtn').addEventListener('click', ()=>{ if(audio && audio.state==='suspended') audio.resume(); newGame(); });
    document.getElementById('howBtn').addEventListener('click', ()=>{ alert('Usa flechas o desliza para mover. Come para crecer. Evita chocar.'); });
    document.getElementById('soundToggle').addEventListener('click', ()=>{ soundOn=!soundOn; document.getElementById('soundToggle').textContent = 'SOUND: '+(soundOn?'ON':'OFF'); });
    document.getElementById('vibeToggle').addEventListener('click', ()=>{ vibOn=!vibOn; document.getElementById('vibeToggle').textContent = 'VIB: '+(vibOn?'ON':'OFF'); });
    document.getElementById('previewBtn').addEventListener('click', ()=>{ renderPreview(); });
    document.getElementById('shareBtn').addEventListener('click', ()=>{ try{ navigator.share && navigator.share({title:'Neon Serpent', text:`Mi puntuaci√≥n ${score}`}); }catch(e){alert('Compartir no soportado en este navegador');} });

    // Game logic - fixed timestep
    let accumulator=0, lastTime=performance.now();
    const step = 16; // ms per simulation tick (approx 60Hz). We'll control move by selectedSpeed timer below.
    let moveTimer = 0; // accumulates ms to decide when to advance snake according to selectedSpeed

    function update(dt){
      // update particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.age += dt; if(p.age>p.life) particles.splice(i,1); else{ p.x += p.vx*(dt/16); p.y += p.vy*(dt/16); p.vy += 0.02*(dt/16); }}

      if(!running) return;
      moveTimer += dt;
      if(moveTimer < selectedSpeed) return;
      moveTimer = 0;

      // apply direction
      dir = nextDir;
      const head = {x:snake[0].x + dir.x, y:snake[0].y + dir.y};
      // collisions
      if(head.x<0 || head.y<0 || head.x>=gridW || head.y>=gridH || snake.some(s=>s.x===head.x && s.y===head.y)){
        // game over
        running=false; overlayGameOver.classList.remove('hidden'); overlayGameOver.style.pointerEvents='auto'; overlayGameOver.querySelector('#finalScore').textContent = score; finalScoreEl.textContent = score; if(score>best){ best=score; localStorage.setItem('neonSerpentBest',best); bestEl.textContent = best; }
        dieSound(); if(vibOn && navigator.vibrate) navigator.vibrate([120]); return;
      }

      snake.unshift(head);
      // eat?
      if(head.x===food.x && head.y===food.y){ score += 10; scoreEl.textContent = score; placeFood(); spawnParticles((food.x+0.5)*GRID_SIZE, (food.y+0.5)*GRID_SIZE, selectedFood.color); popSound(); if(vibOn && navigator.vibrate) navigator.vibrate(20); }
      else{ snake.pop(); }
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const w = canvas.width / dpr; const h = canvas.height / dpr;
      // subtle background grid lines
      ctx.save();
      ctx.globalAlpha = 0.06; ctx.strokeStyle = '#88a0ff'; ctx.lineWidth = 1;
      for(let x=0;x<=w;x+=GRID_SIZE){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h); ctx.stroke(); }
      for(let y=0;y<=h;y+=GRID_SIZE){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5); ctx.stroke(); }
      ctx.restore();

      // draw food with glow pulse
      const fx = food.x*GRID_SIZE, fy = food.y*GRID_SIZE;
      const pulse = 0.8 + Math.sin(performance.now()/160)*0.2;
      ctx.save(); ctx.globalAlpha = 0.95; ctx.font = (GRID_SIZE-2)+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.shadowColor = selectedFood.color; ctx.shadowBlur = 12 * pulse; ctx.fillStyle = selectedFood.color;
      ctx.fillText(food.type.emoji, fx + GRID_SIZE/2, fy + GRID_SIZE/2);
      ctx.restore();

      // draw snake with gradient and glow
      for(let i=0;i<snake.length;i++){
        const s = snake[i]; const x = s.x*GRID_SIZE, y = s.y*GRID_SIZE;
        const progress = i / Math.max(1, snake.length-1);
        const alpha = 1 - progress*0.55;
        ctx.save(); ctx.fillStyle = selectedColor; ctx.globalAlpha = alpha;
        // glow for head
        if(i===0){ ctx.shadowColor = selectedColor; ctx.shadowBlur = 14; }
        // rounded rect
        roundRect(ctx, x+1, y+1, GRID_SIZE-2, GRID_SIZE-2, 6); ctx.fill(); ctx.restore();
        // outline
        ctx.save(); ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1; roundRect(ctx, x+1, y+1, GRID_SIZE-2, GRID_SIZE-2, 6); ctx.stroke(); ctx.restore();
      }

      // particles
      for(const p of particles){ ctx.save(); ctx.globalAlpha = 1 - p.age/p.life; ctx.fillStyle = p.color || '#fff'; ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(1,4*(1 - p.age/p.life)),0,Math.PI*2); ctx.fill(); ctx.restore(); }

      // mini vignette
      ctx.save(); ctx.globalCompositeOperation = 'overlay'; ctx.fillStyle = 'rgba(0,0,0,0.07)'; ctx.fillRect(0,0,w,h); ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){ if(w<2*r) r=w/2; if(h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    // Preview render when idle
    function renderPreview(){
      // simple decorative preview of snake and food centered
      setCanvasSize();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const cx = Math.floor(gridW/2), cy = Math.floor(gridH/2);
      // draw a short snake
      const previewSnake = [ {x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy} ];
      const tmpFood = {x:cx+3,y:cy};
      // background grid
      ctx.save(); ctx.globalAlpha = 0.04; ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr); ctx.restore();
      // draw snake
      for(let i=0;i<previewSnake.length;i++){ const s=previewSnake[i]; const x=s.x*GRID_SIZE,y=s.y*GRID_SIZE; ctx.save(); ctx.fillStyle=selectedColor; ctx.globalAlpha = 1 - i*0.25; roundRect(ctx,x+1,y+1,GRID_SIZE-2,GRID_SIZE-2,6); ctx.fill(); ctx.restore(); }
      ctx.save(); ctx.font=(GRID_SIZE-4)+'px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor=selectedFood.color; ctx.shadowBlur=8; ctx.fillStyle=selectedFood.color; ctx.fillText(selectedFood.emoji, tmpFood.x*GRID_SIZE+GRID_SIZE/2, tmpFood.y*GRID_SIZE+GRID_SIZE/2); ctx.restore();
    }

    // Main loop
    let lastFpsTime = performance.now(), frames=0;
    function loop(now){
      const dt = Math.min(100, now - lastTime); lastTime = now;
      accumulator += dt;
      while(accumulator >= step){ update(step); accumulator -= step; }
      draw();
      // fps
      frames++; if(now - lastFpsTime >= 500){ const fps = Math.round((frames*1000)/(now-lastFpsTime)); fpsEl.textContent = fps; frames=0; lastFpsTime = now; }
      requestAnimationFrame(loop);
    }

    // responsive handling
    function onResize(){ setCanvasSize(); renderPreview(); }
    window.addEventListener('resize', onResize);

    // start
    onResize(); renderPreview(); lastTime = performance.now(); requestAnimationFrame(loop);

    // expose small API for share with main UI
    window.__neon = { newGame, placeFood, getState:()=>({running,score,best}), setColor:c=>{selectedColor=c}, spawnParticles };

  })();
  </script>
</body>
</html>
